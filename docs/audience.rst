===============
Target audience
===============

Who is the target audience of the pymetacode package? Is it interesting for me?


Routine software developers
===========================

The pymetacode package aims at **routine software developers who focus on consistency, portable and deployable code**, are not afraid of using unit tests and Sphinx for their documentation, and are bored by having to copy&paste code (and too often forget to change some things this way).

You will (not so) occasionally create a new Python package and regularly add classes (and functions) to your code. While some IDEs can be configured to some extent regarding class stubs, it is not that easy to have a class stub and a corresponding test class stub created at the same time from within an IDE. Not so with pymetacode, where all is done with a single command.


Academic programmers
====================

At the same time, using the pymetacode package in an **academic context** can be quite useful. Here, many programmers acquired their programming skills on the go and never received a formal training in software engineering. Nevertheless, they are now faced with implementing, further developing and maintaining large code bases that should be both, **consistent and maintainable**.

Clearly, pymetacode does not help with the occasional Python script. But honestly, programming particularly in science transforms much quicker into full-fledged software development than we might think (and like). Even worse, not so many people are aware of the problems connected with this transition between (occasional) programming and software development.


Opinionated
===========

The pymetacode package is clearly **opinionated**, making a lot of decisions on how to do things, starting with the overall package directory layout. Nevertheless, it tries to go out of the way of the programmer as much as possible and provides a simple, yet powerful command-line interface (CLI) for the daily usage.

**Fun fact:** The package itself has been developed originally by using a predecessor of itself and continues to be developed by help of itself. Hence, it less of an intellectual playground than a tool for the daily business of a routine programmer.

